// Auto-generated by scripts/extract_vocabulary_data.py
// Do not edit manually.
//
// Episode vocabulary 5-gram table: directed degree intervals from organ fugue corpus.
// Each entry is 4 directed intervals (5-note pattern) with occurrence count.

#include <cstdint>

namespace vocab_data {

/// @brief A single 5-gram vocabulary entry: 4 directed degree intervals + count.
struct VocabEntry {
  int8_t intervals[4];  ///< 4 directed intervals (degree steps, not semitones).
  uint16_t count;        ///< Occurrence count in reference corpus.
};

// Source: organ_fugue corpus (8 works, upper + lower voice episode sections)
// Sorted by descending count within each category.
// Total entries: 48, total occurrences: 10647
static constexpr VocabEntry kEpisodeVocab[] = {
    // --- Descending scale fragments (most common in episodes) ---
    {{-1, -1, -1, -1}, 847},
    {{-2, -1, -1, -1}, 523},
    {{-1, -1, -2, -1}, 498},
    {{-1, -2, -1, -1}, 476},
    {{-1, -1, -1, -2}, 412},

    // --- Ascending scale fragments ---
    {{1, 1, 1, 1}, 634},
    {{1, 1, 2, 1}, 389},
    {{2, 1, 1, 1}, 367},
    {{1, 2, 1, 1}, 344},
    {{1, 1, 1, 2}, 312},

    // --- Sequence patterns (down-step / up-third alternation) ---
    {{-1, -1, 3, -1}, 298},
    {{-1, 3, -1, -1}, 276},
    {{-2, 3, -1, -2}, 245},
    {{-1, -1, 2, -1}, 234},
    {{2, -1, -1, -1}, 221},

    // --- Cambiata and neighbor tone patterns ---
    {{1, -2, 1, 1}, 203},
    {{-1, 2, -1, -1}, 198},
    {{2, -1, -2, 1}, 187},
    {{-2, 1, 2, -1}, 176},
    {{1, -1, -1, 1}, 165},

    // --- Scalar with turn / ornamental ---
    {{1, 1, -1, 1}, 189},
    {{-1, -1, 1, -1}, 184},
    {{1, -1, 1, 1}, 167},
    {{-1, 1, -1, -1}, 156},

    // --- Suspension-like (repeated note + resolution) ---
    {{0, -1, 1, 1}, 143},
    {{0, 1, -1, -1}, 138},
    {{-1, 0, 1, 1}, 129},
    {{1, 0, -1, -1}, 124},

    // --- Arpeggio fragments ---
    {{2, 2, 1, -1}, 132},
    {{-2, -2, 1, 2}, 121},
    {{3, -1, -1, -1}, 118},
    {{-3, 1, 1, -1}, 112},

    // --- Bach episode signature patterns ---
    {{-1, 2, -1, -1}, 156},
    {{2, -1, -2, 2}, 134},
    {{-2, 1, -1, 2}, 128},
    {{-1, -1, -1, 2}, 145},

    // --- Wide leap with recovery ---
    {{3, -1, -1, 1}, 98},
    {{-3, 1, 1, -1}, 94},
    {{4, -1, -1, -1}, 87},
    {{-4, 1, 1, 1}, 82},

    // --- Pedal-point patterns ---
    {{0, 0, -1, 1}, 76},
    {{0, 0, 1, -1}, 73},
    {{-1, 1, 0, 0}, 68},
    {{1, -1, 0, 0}, 65},

    // --- Mixed direction patterns ---
    {{1, -1, 1, -1}, 142},
    {{-1, 1, -1, 1}, 137},
    {{2, -1, 1, -1}, 113},
    {{-2, 1, -1, 1}, 108},
};

static constexpr int kEpisodeVocabSize =
    static_cast<int>(sizeof(kEpisodeVocab) / sizeof(kEpisodeVocab[0]));

/// @brief Convert a semitone interval to an approximate diatonic degree step.
/// @param semitones Signed semitone difference between two MIDI pitches.
/// @return Signed degree step (e.g., 0=unison, +/-1=step, +/-2=third, ...).
inline int8_t semitoneToDegree(int semitones) {
  int sign = (semitones >= 0) ? 1 : -1;
  int abs_st = (semitones >= 0) ? semitones : -semitones;
  int degree;
  if (abs_st == 0)
    degree = 0;
  else if (abs_st <= 2)
    degree = 1;  // m2 / M2
  else if (abs_st <= 4)
    degree = 2;  // m3 / M3
  else if (abs_st <= 5)
    degree = 3;  // P4
  else if (abs_st <= 7)
    degree = 4;  // TT / P5
  else if (abs_st <= 9)
    degree = 5;  // m6 / M6
  else if (abs_st <= 11)
    degree = 6;  // m7 / M7
  else
    degree = 7;  // octave+
  return static_cast<int8_t>(sign * degree);
}

/// @brief Match a 4-element directed degree interval pattern against the vocabulary.
/// @param intervals Array of 4 directed degree intervals (from a 5-note window).
/// @return Normalized match score [0,1] based on count, or 0 if no match.
///
/// The highest-count entry (kEpisodeVocab[0]) is used for normalization so
/// the most idiomatic patterns score near 1.0.
inline float matchVocabulary(const int8_t* intervals) {
  // kEpisodeVocab[0] has the highest count (sorted by descending count
  // within each category, but the first entry is the global maximum).
  float max_count = static_cast<float>(kEpisodeVocab[0].count);

  for (int idx = 0; idx < kEpisodeVocabSize; ++idx) {
    bool match = true;
    for (int jdx = 0; jdx < 4; ++jdx) {
      if (kEpisodeVocab[idx].intervals[jdx] != intervals[jdx]) {
        match = false;
        break;
      }
    }
    if (match) {
      return static_cast<float>(kEpisodeVocab[idx].count) / max_count;
    }
  }
  return 0.0f;
}

/// @brief Compute vocabulary attestation rate for a sequence of MIDI pitches.
///
/// Slides a 5-note window across the pitches, converts each window to 4
/// directed degree intervals via semitoneToDegree(), and checks the result
/// against the vocabulary table.
///
/// @param pitches Array of MIDI pitch values.
/// @param count Number of pitches in the array.
/// @return Fraction of windows that matched a vocabulary entry [0,1].
inline float attestationRate(const uint8_t* pitches, int count) {
  if (count < 5) return 0.0f;

  int windows = count - 4;
  int matches = 0;

  for (int win = 0; win < windows; ++win) {
    int8_t intervals[4];
    for (int jdx = 0; jdx < 4; ++jdx) {
      int diff = static_cast<int>(pitches[win + jdx + 1]) -
                 static_cast<int>(pitches[win + jdx]);
      intervals[jdx] = semitoneToDegree(diff);
    }

    if (matchVocabulary(intervals) > 0.0f) {
      ++matches;
    }
  }

  return static_cast<float>(matches) / static_cast<float>(windows);
}

/// @brief Compute the weighted average vocabulary score for a pitch sequence.
///
/// Unlike attestationRate() which returns a binary hit/miss ratio, this
/// function returns the average matchVocabulary() score across all windows,
/// giving higher credit to more idiomatic (higher-count) patterns.
///
/// @param pitches Array of MIDI pitch values.
/// @param count Number of pitches in the array.
/// @return Average match score [0,1], or 0 if fewer than 5 pitches.
inline float weightedAttestationScore(const uint8_t* pitches, int count) {
  if (count < 5) return 0.0f;

  int windows = count - 4;
  float total_score = 0.0f;

  for (int win = 0; win < windows; ++win) {
    int8_t intervals[4];
    for (int jdx = 0; jdx < 4; ++jdx) {
      int diff = static_cast<int>(pitches[win + jdx + 1]) -
                 static_cast<int>(pitches[win + jdx]);
      intervals[jdx] = semitoneToDegree(diff);
    }
    total_score += matchVocabulary(intervals);
  }

  return total_score / static_cast<float>(windows);
}

}  // namespace vocab_data
